Applyの設計
==========
LangExtでは、OptionやResultに対して関数を適用できる機能としてApplyモジュールを提供しています。
ここでは、このApplyの設計上の選択について説明します。

Applyとは
--------
Applyモジュールは、OptionやResult（以降、モナド）に対して関数を適用できる機能を提供します。

モナドに対しての関数適用は、Bind関数やクエリ式によって行われますが、Applyモジュールはそのファサードとして機能します。
このファサードは、束縛を含まないような単純な関数適用に特化しています。

名前の選択
---------
Applyモジュールは、HaskellのApplicativeに影響を受けたので、最初は名前もそのまま輸入することを考えました。
ただし、C#はHaskellほど演算子オーバーロードを自由に行えず、演算子を使わずに`Applicative.Apply`のようにすると名前が長くなり
ファサードとしての役割が弱くなってしまいます。

次に、名前を短くするために、`App.ly`という名前を考案しました。
しかしながら、これはC#のコーディング規約に違反しているため却下されました。

C#にはメソッドチェーンという文化があります。
最終的には、Applyモジュールはこの文化にのっとり関数の適用の対象（To）と関数(Of)を分離することにしました。
そして下記のようになりました。

```cs
Apply.To(o1, o2, ..., o16).By(func)
```

HaskellのApplicativeとは、適用の順番が逆であることに注意してください。
これは、C#では関数合成のサポートがなく、代わりにラムダ式を使う頻度が高いのでByの引数式のほうが長くなることを考慮したためです。

ファンクタについて
-------------
HaskellのApplicativeはモナドに対してではなくファンクタに対して適用が行われます。
しかしながら、C#では型クラスをエミュレートすることが難しく、各々のモナドをファンクタとして汎化することができないので、
Applyモジュールでは、オーバーロードによるアドホックな多態性により各モナドをサポートしています。

LangExt1.xからの移行
--------------------
LangExt1.xではApplyモジュールは存在しません。
しかし下記のような式があったときApplyモジュールを利用することで、よりシンプルなコードにすることができます。

```cs
from x1 in o1
from x2 in o2
....
select func(x1, x2, ..., x3)
```

下記のように置き換えます。
```cs
Apply.To(o1, o2, ..., o16).By(func)
```