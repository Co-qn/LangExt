LangExt
=======
LangExtは、C#での関数プログラミングをサポートすることを主な目的としたライブラリです。
LangExtを使用することで、冗長な記述を極力排し、かつバグを埋め込みにくいプログラミングが可能となります。

LangExtはC#が目指せなかった(目指さなかった)場所を目指すためのライブラリになっています。
程度の差はあれ、ライブラリを使うためには、そのライブラリが提供する語彙を覚えるか知っている必要があります。
LangExtは関数型言語から語彙を借りてきているため、標準的なC#の流儀からは反するものもいくつかあります。
そのあたりを理解して使用してください。

用語
----
このドキュメントおよびLangExtで使用する用語の説明です。

### 関数
staticメソッドを単に「関数」と記述しています。

### モジュール
staticクラスのことをモジュールと記述しています。

LangExtが提供するジェネリック型に対しては同名のモジュールに拡張メソッドを含む関数を定義します。
それに対して、LangExtが提供する非ジェネリック型には、型名の後ろに「Module」というサフィックスを付けたモジュール名を使います。

LangExt以外で提供される型に対する関数の定義は、ジェネリック型と同名の非ジェネリック型を持たない型と、それ以外の型で扱いが異なります。
ジェネリック型と同名の非ジェネリック型を持たない型の場合、ジェネリック型と同名のモジュールに拡張メソッドを含む関数を定義します。
例えば、System.Funcなどがこれに該当し、Funcモジュールに関数を定義しています。
それに対して、ジェネリック型と同名の非ジェネリックを持つ型、あるいは非ジェネリック型の場合、
型名の後ろに「Module」というサフィックスを付けたモジュール名を使います。
例えば、System.Tupleなどがこれに該当し、TupleModuleモジュールに関数を定義しています。

また、インターフェイスに対するモジュールの場合、Iプレフィックスを取り除いた名前を使います。

### 型
モジュール以外のクラスや、構造体、列挙型などをまとめて、型と記述しています。

### シーケンス
ISeq[T]のことを、シーケンスと呼びます。
LangExtではLINQ to Objectsを捨て、シーケンスに対して「より関数プログラミングの語彙に近いAPI」を再構築しています。
その際に、IEnumerable[T]ではなく、ISeq[T]を操作の対象に選んだため、配列との統一的なAPIは諦めています。
しかし、オーバーロードを極力排除したことにより、LINQ to Objectsよりも拡張の幅が大きくなっています。

表記
----
このドキュメントおよびLangExtで使用する表記の説明です。

### 関数の型
関数の型は、

```
(int, int) → int
```

のように、引数の型と戻り値の型を`→`で区切った形式で記述します。
上の例は、intを2つ受け取ってintを返す関数です。
引数が1つの場合は、引数を囲むかっこを省略します。

Funcデリゲートの型も同様に、引数の型と戻り値の型を`→`で区切って表しますが、全体をかっこで囲みます。

```
(int → int)
```

これは、intを受け取ってintを返すFuncデリゲートを表します。
Actionデリゲートは、戻り値の型としてvoidを指定します(例えば`(int → void)`は、intを受け取るActionデリゲートを表す)。

### 型パラメータ
型パラメータは、Tから始まる一文字の大文字(T, U, V, ...)で記述します。
例えば、Tを受け取ってTを返す関数は、

```
T → T
```

です。
これに続けて、番号を付ける場合もあります(T1, T2, ...)。

型パラメータに明確な意味があるような場合、Tに続けて意味を表す語を続けます。
例えば、成功の場合の型をTSuccessとして表し、失敗の場合の型をTFailureとして表したりします。

### ジェネリック型
ジェネリック型は、

```
Option[T]
```

のように角かっこを用います。
これは、ドキュメンテーションコメントの可読性を考慮した結果です。

### タプル
タプルの型は、各要素の型をアスタリスクで連結して記述します。
例えば、T1とT2のタプルの型は、

```
T1 * T2
```

です。
タプルを受け取る関数(タプル関数)と複数引数の関数は、以下のように区別されます。

```
T1 * T2 → U
(T1, T2) → U
```

### シーケンス
波かっこの中にカンマ区切りで要素を列挙することで、シーケンスの値を表します。
例えば、要素として1～3の整数を含むシーケンスは、

```
{ 1, 2, 3 }
```

と表記します。


LangExtが提供する主な型とモジュール
------------------------------------
LangExtが提供する主な型とモジュールについて、その役割や意味を簡単に説明します。
実際の使い方に関しては、ドキュメンテーションコメントを参考にしてください。

### Placeholder型
Placeholder型は、プレースホルダーとして使用されることを前提とした型です。

この型をユーザが明示的に使用することはありません。
この型は、Option型を型パラメータを指定せずに生成したりするために使用されます。
基本的には暗黙の型変換のために使用されますが、具体的な使用例はOption型などを参照してください。

この型の値に意味はないため、列挙子を持たない列挙型として実装されています。
数値をキャストすることでこの型の値を作ることはできますが、そうした場合の動作は保証しませんので注意してください。

### Unit型
Unit型は、意味を持つ値がないことを表すための型です(0bitの情報を持つ型とも言えるでしょう)。
この型は列挙型として実装されており、`\_`という唯一の列挙子を持ちます。

voidとの違いは、voidは値がないうえに、型パラメータとして使用することができないのに対して、Unit型はそうではないという点です。
値がない場合とある場合を共通化したい場合、Unit型が使用できます。

数値をキャストすることでこの型の`\_`以外の値を作ることはできますが、そうした場合の動作は保証しませんので注意してください。

### Option型
Option型は、失敗しうる計算の結果として使用できる型です。
この型は、nullなどを使うよりも安全に「値がないこと」を表すことができます。

出力引数もこの目的に使用できます(たとえば、int.TryParse等)が、出力引数は結果格納用の変数を用意する必要があります。

```csharp
int result;
if (int.TryParse(str, out result))
{
    // Parseに成功した場合の処理
}
else
{
    // Parseに失敗した場合の処理
}
```

これに対してOption型は、その必要がありません。

```csharp
str.TryToInt().Match(
    Some: result => /* 変換に成功した場合の式 */,
    None: () => /* 変換に失敗した場合の式 */);
```

Optionを使用すると、式として記述できる表現の幅が大きく広がるため、単純なラムダ式で記述できる処理の幅も大きく広がります[^match]。

[^match]: Match関数で名前付き引数を使うアイディアは、[ころくんのつぶやき][korotweet]から借りています。
[korotweet]: https://twitter.com/koropicot/status/315132868915523586

#### Optionモジュール
Option型の値を生成するためには、Optionモジュールの関数・プロパティを使用します。
Option.Some/Option.None以外に、Option.Createという関数により、nullの場合はNoneとして、それ以外の場合はSomeとしてOptionオブジェクトを生成できます。

#### クエリ式
Option型はクエリ式で使うこともできます。

```csharp
from a in F1() // Option[int]を返す関数F1
from b in F2() // Option[int]を返す関数F2
from c in F3() // Option[string]を返す関数F3
select c + (a + b)
```

F1の結果を捨てる場合、&&演算子を使うことで余分な変数名の導入を避けることでできます。

```csharp
// F1の結果は捨て、F2の結果のみ使う
from a in F1() && F2()
from c in F3()
select c + a
```

ただし、これができるのは&&の両辺の型が同じである時のみです。
もし型が違う場合は、AndThenメソッドが使えます。

```csharp
// F1の結果は捨て、F3の結果のみ使う
from c in F1().AndThen(() => F3()) // もしくは単に F1().AndThen(F3)
from b in F2()
select c + b
```

これらのイディオムは、クエリ式内で値を捨てることができないC#では重要です。

クエリ式は、「一つでも失敗したら失敗する」ことを表現しますが、||演算子を使うことで「一つでも成功したら成功する」ことも表現できます。

```csharp
return F1() || F2() || F3().Map(int.Parse);
```

この場合、すべての戻り値の型が同じである必要があります。

null合体演算子のオーバーロードが可能であれば、GetOrElseメソッドの代わりにそちらを使うことができるようになるのですが、
現在のC#はこれを許していないため、GetOrElseメソッドを使用する必要があります。
また、null合体演算子の連続`opt1 ?? opt2 ?? opt3 ?? defaultValue`を実現するためには、`(opt1 || opt2 || opt3).GetOrElse(() => defaultValue)`のように記述する必要があります。
defaultValue部分が単純な値の場合(生成コストが低く、副作用を起こすような計算ではない場合)、`GetOrElse(() => defaultValue)`の代わりに、`GetOr(defaultValue)`としてもいいでしょう。

### Result型
Option型は、失敗の原因を保持することができません。
Result型では、失敗の原因も保持することができます。

#### Failureの操作
Result型はOption型と違い、失敗の原因を保持することができます。
失敗側の値に対する操作を行いたい場合もあるため、これに対応しています。
失敗側の値に対して操作を行いたい場合は、成功側の操作に、サフィックス「Failure」を付けます。

例えば、失敗側の結果に対してMapが行いたい場合は、

```csharp
res.MapFailure(e => e.ToString());
```

のように記述します。

失敗側に対してクエリ式が使いたい場合は、SwapResultを呼び出すことで成功と失敗を入れ替えることで一応実現できます。
クエリ式による操作が終わったら、再びSwapResultを呼び出してください。

### ISeq型/Seqモジュール
ISeq[T]は、Tのシーケンスを表します。

関数を引数に渡す高階関数のうち、インデックスを取るバージョンはWithIndexで終わります。
例えば、MapWithIndexは`(T, int) → U`という関数を受け取り、第二引数に現在の要素のインデックスが渡されてきます。

失敗する可能性のある関数に対しては、Optionを返すバージョンを提供しています。
Optionを返すバージョンの関数は、Tryから始まります。
例えば、Findは要素が見つからなかった場合に例外を投げますが、TryFindはNoneを返します。

#### Optionを含むシーケンスの変換
Optionのシーケンスに対する2つの関数、SequeneとOnlySomeを提供しています。

Sequenceは、OptionのシーケンスがSomeのみを含む場合にSomeをシーケンスの外側にくくり出します。
一つでもNoneが含まれていた場合、Noneとなります。
例えば、`{ Some(1), Some(2), Some(3) }`とあった場合、`Some { 1, 2, 3 }`となり、
`{ Some(1), Some(2), None }`とあった場合、`None`になります。

OnlySomeは、OptionのシーケンスからSomeの要素のみを集め、Someを取り除きます。
例えば、`{ Some(1), Some(2), None, Some(3) }`とあった場合、`{ 1, 2, 3 }`となります。

#### Resultを含むシーケンスの変換
Optionを含むシーケンスの変換同様の操作が、Resultに対しても提供されています。
Sequenceに対してはSequenceSuccess/SequenceFailureが、OnlySomeに対してはOnlySuccess/OnlyFailureがそれぞれ対応します。

#### nullを含みうるシーケンスの変換
MapOption関数を使うことで、nullを含みうるシーケンスを、Optionのシーケンスに変換できます。

参照型の場合は`ISeq[T] → ISeq[Option[T]]`ですが、null許容型の場合`ISeq[T?] → ISeq[Option[T]]`と、
null許容型が取り除かれることに注意してください。

#### クエリ式の提供
シーケンスはクエリ式も提供しています。
LINQ to Objectsが提供しているクエリ式はすべて使用可能です。

#### IEnumerableについて
IEnumerable[T]に対してもいくつか拡張メソッドを定義していますが、シーケンスに比べると限定的です。

基本的には、IEnumerable[T]は使わず、ISeq[T]を使います。
ToSeqメソッドによって、IEnumerable[T]をシーケンスに変換できます。

### Createモジュール
Createモジュールは、LangExtやC#の標準ライブラリで扱うことのできる様々な型の値を生成するための関数を提供します。

たとえば、Create.Array(1, 2, 3)とすると、1, 2, 3という要素を持った配列を生成することができます。
この程度の例であれば、配列リテラルを使用したほうがいいですが、配列リテラルは関数として扱うことができませんので、高階関数の引数等に指定できません。
そういう場合にこのモジュールは役に立つでしょう(もちろん、値を生成するために便利な場合もあります)。

### TupleModuleモジュール
TupleModuleモジュールは、C#標準のタプルを使いやすくするための拡張メソッドを提供します。

C#標準のタプルは、7要素までしか自然に扱うことができませんが、TupleModuleモジュールを使うことで型の記述以外は16要素まで自然に扱うことができるようになります。
例えば、標準ライブラリでは16要素タプルの15要素目にアクセスするためには`tpl.Rest.Rest.Item1`と記述する必要がありますが、LangExtを使うと`tpl.\_15()`と書けます。
タプルの生成も、9要素以上はコンストラクタを使う必要があるため、非常に面倒です。

```csharp
var tpl = new Tuple<T1, T2, ..., T7, Tuple<T8, T9, ..., T14, Tuple<T15, T16>>>(
    t1, t2, ..., t7, new Tuple<T8, T9, ..., T14, Tuple<T15, T16>>(
        t8, t9, ..., t14, Tuple.Create(t15, t16)));
```

LangExtでは、これもとても簡単に記述できます。

```csharp
// TupleModule.Createでも可
var tpl = Create.Tuple(t1, t2, ..., t16);
```

ほかにも、タプルの擬似的なパターンマッチや、指定要素に対するMapなどが可能です。

C#ではそもそもタプルを多用すべきではありません(無名型が使えるのであればそちらを使うといいでしょう)。
このモジュールは自動生成や、次に説明するFuncモジュールのために実装されています。
このモジュールで扱えるタプルの要素数が16までなのは、標準のFuncデリゲートが16引数までしか対応していないためです。

### Funcモジュール
Funcモジュールは、Funcデリゲートの機能を強化する関数を提供します。

このモジュールには、複数引数の関数「(T1, ..., Tn) → U」、タプル関数「T1 * ... * Tn → U」、カリー化関数「T1 → ... → Tn → U」の相互変換を行う関数を提供しています。
以降ではT1とT2を受け取ってUを返す関数のみ記載していますが、T16まですべて対応しています。

#### 複数引数関数とカリー化関数の相互変換
複数引数関数をカリー化関数に変換する関数`((T1, T2) → U) → (T1 → T2 → U)`を、Curryという名前で提供しています。拡張メソッド版に、Curriedも提供しています。
これの逆操作`(T1 → T2 → U) → ((T1, T2) → U)`を、Uncurryという名前で提供し、拡張メソッド版としてUncurriedも提供しています。

CurryしてUncurryすると、意味としては何もしていないのと同じです。

#### タプル関数とカリー化関数の相互変換
タプル関数をカリー化関数に変換する関数`(T1 * T2 → U) → (T1 → T2 → U)`を、CurryXという名前で提供しています。拡張メソッド版に、CurriedXも提供しています。
これの逆操作`(T1 → T2 → U) → (T1 * T2 → U)`を、UncurryXという名前で提供し、拡張メソッド版としてUncurriedXも提供しています。
サフィックスとして使われているXは、タプルを表すアスタリスクが由来です[^derivation]。

CurryXしてUncurryXすると、意味としては何もしていないのと同じです。

[^derivation]: サフィックスのXがタプルを表すアスタリスクから来ている、というのは、こじつけの理由で、これに至るまでに紆余曲折を経ています。
    当初は、`(T1 * T2 → U) → (T1 → T2 → U)`をCurry、`(T1 → T2 → U) → (T1 * T2 → U)`をUncurryにしようとしていましたが、
    Curryは引数の型の違うオーバーロードとして実現できるものの、Uncurryは戻り値の型が違うだけになるため、別の名前が必要でした。
    
    これにUncurry2と名前を付けてしまうと、紛らわしい(2引数版、2要素タプル版と勘違いしてしまう)という懸念があり、早々に却下されました。
    Tupleという名前も考慮しましたが、これでは対称性が取れないという別の問題が生じます。
    他の似たようなメソッドはCurryに対してUncurry、Tupleに対してUntupleとなっているため、ここだけCurryに対してTupleを採用するのは統一性がありません。

    そこで、CurryとUncurryを基本に、意味のない語を付ける案に至りました。
    候補としてあがったものは、XやZ、アンダースコアなどです。
    Xを選んだのは、Xがタプルを表すアスタリスクに見えるから、という由来として挙げた理由からです。

    Xを選んだものの、プレフィックスにするかサフィックスにするかは迷いました。
    正直、こじつけで理由はあるものの、意味のない語であるため、どうでもよかったのです。
    ただ、Xの後に母音が来ると、そのまま読めてしまうのが微妙な感じがしたので、Xuncurryではなく、UncurryXの方が良さそうでした。
    こういう経緯を経て、タプル関数とカリー化関数の相互変換関数の名前がCurryXとUncurryXに決まりました。

#### 複数引数関数とタプル関数の相互変換
複数引数関数をタプル関数に変換する関数`((T1, T2) → U) → (T1 * T2 → U)`を、Tupleという名前で提供しています。拡張メソッド版に、Tupledも提供しています。
これの逆操作`(T1 * T2 → U) → ((T1, T2) → U)`を、Untupleという名前で提供し、拡張メソッドとしてUntupledも提供しています。

TupleしてUntupleすると、意味としては何もしていないのと同じです。

#### Option型を返す関数への変換
以降では、Tを受け取ってUを返す関数のみ記載していますが、
T16までの複数引数関数すべてに対応しています(カリー化関数やタプル関数には対応していないので、これらの関数に使いたい場合は、変換関数で複数引数関数に変換する必要があります)。

nullを返しうる関数`T → U`を、`T → Option[U]`に変換する関数を、NullToOptionという名前で提供しています。
この関数は、渡された関数の結果がnullだった場合にNoneとして返し、それ以外の場合はSomeでその値を包んで返します。
Uにclass制約が付いた形で提供されるほか、Uにstruct制約が付いた形で`T → U?`に対して、`T → Option[U]`に変換するバージョンも提供しています。
後者の場合、null許容型`U?`がnullを許容しない型`Option[U]`に変化する点に注意してください(nullはNoneで表されるため、不要になります)。

例外を投げうる関数`T → U`を、`T → Option[U]`に変換する関数を、ExnToOptionという名前で提供しています。ExnはF#(もしくはOCaml)由来の短縮です。
この関数は、渡された関数が例外を投げた場合にNoneとして返し、それ以外の場合はSomeでその値を包んで返します。

上記2つを同時に行う関数を、ToOptionという名前で提供しています。

これらの逆操作は提供していません。

#### Result型を返す関数への変換
以降では、Tを受け取ってUを返す関数のみ記載していますが、
T16までの複数引数関数すべてに対応しています(カリー化関数やタプル関数には対応していないので、これらの関数に使いたい場合は、変換関数で複数引数関数に変換する必要があります)。

nullを返しうる関数`T → U`を、`T → Result[U, Unit]`に変換する関数を、NullToResultという名前で提供しています。
この関数は、渡された関数の結果がnullだった場合にFailureとして返し、それ以外の場合はSuccessでその値を包んで返します。
Uにclass制約が付いた形で提供されるほか、Uにstruct制約が付いた形で`T → U?`に対して、`T → Result[U, Unit]`に変換するバージョンも提供しています。
後者の場合、null許容型`U?`がnullを許容しない型`Result[U, Unit]`に変化する点に注意してください(nullはFailureで表されるため、不要になります)。

例外を投げうる関数`T → U`を、`T → Result[U, Exception]`に変換する関数を、ExnToResultという名前で提供しています。ExnはF#(もしくはOCaml)由来の短縮です。
この関数は、渡された関数が例外を投げた場合にFailureで例外を包んで返し、それ以外の場合はSuccessでその値を包んで返します。

上記2つを同時に行う関数を、ToOptionという名前で提供しています。
nullを返したことを表現するために、NullResultExceptionという名前の例外クラスを使っています。

これらの逆操作は提供していません。

