LangExt
=======
LangExtは、C#での関数プログラミングをサポートすることを主な目的としたライブラリです。
LangExtを使用することで、冗長な記述を極力排し、かつバグを埋め込みにくいプログラミングが可能となります。

このライブラリは標準的なC#の流儀に反している部分が多くあります(もちろん理由があります)。
そのため、このライブラリは気軽に採用せず、それらを理解したうえで使用してください。

用語
----
このドキュメントおよびLangExtで使用する用語の説明です。

### 関数
staticメソッドを単に「関数」と記述しています。

### モジュール
staticクラスのことをモジュールと記述しています。

LangExtが提供するジェネリック型に対しては同名のモジュールに拡張メソッドを含む関数を定義します。
それに対して、LangExtが提供する非ジェネリック型や、LangExt以外で提供される型に対する関数の定義には、
型名の後ろに「Module」というサフィックスを付けたモジュール名を使います。

たとえば、LangExtが提供するジェネリック型であるOption型に対する関数はOptionモジュールに定義し、
.NET Frameworkが提供する型であるSystem.Object型に対する関数はObjectModuleモジュールに定義します。

### 型
モジュール以外のクラスや、構造体、列挙型などをまとめて、型と記述しています。

### シーケンス
T型のIEnumerableをシーケンスと記述しています。

表記
----
このドキュメントおよびLangExtで使用する表記の説明です。

### 関数の型
関数の型は、

```
(int, int) → int
```

のように、引数の型と戻り値の型を`→`で区切った形式で記述します。
上の例は、intを2つ受け取ってintを返す関数です。
引数が1つの場合は、引数を囲むかっこを省略します。

Funcデリゲートの型も同様に、引数の型と戻り値の型を`→`で区切って表しますが、全体をかっこで囲みます。

```
(int → int)
```

これは、intを受け取ってintを返すFuncデリゲートを表します。
Actionデリゲートは、戻り値の型としてvoidを指定します(例えば`(int → void)`は、intを受け取るActionデリゲートを表す)。

### 型パラメータ
型パラメータは、Tから始まる一文字の大文字で記述します。
例えば、Tを受け取ってTを返す関数は、

```
T → T
```

です。

### ジェネリック型
ジェネリック型は、

```
Option[T]
```

のように角かっこを用います。
これは、ドキュメンテーションコメントの可読性を考慮した結果です。

LangExtが提供する主な型とモジュール
------------------------------------
LangExtが提供する主な型とモジュールについて、その役割や意味を簡単に説明します。
実際の使い方に関しては、ドキュメンテーションコメントを参考にしてください。

### Undefined型
Undefined型は、プレースホルダーとして使用されることを前提とした型です。

この型をユーザが明示的に使用することはありません。
この型は、Option型を型パラメータを指定せずに生成したりするために使用されます。
基本的には暗黙の型変換のために使用されますが、具体的な使用例はOption型などを参照してください。

この型の値に意味はないため、列挙子を持たない列挙型として実装されています。
数値をキャストすることでこの型の値を作ることはできますが、そうした場合の動作は保証しませんので注意してください。

### Unit型
Unit型は、値がないことを表すための型です。
voidは値がないうえに、型パラメータとして使用することができません。
値がない場合とある場合を共通化したい場合、Unitが使用できます。

### Option型
Option型は、失敗しうる計算の結果として使用できる型です。
この型は、nullなどを使うよりも安全に「値がないこと」を表すことができます。

出力引数もこの目的に使用できます(たとえば、int.TryParse等)が、出力引数は結果格納用の変数を用意する必要があります。

```csharp
int result;
if (int.TryParse(str, out result))
{
    // Parseに成功した場合の処理
}
else
{
    // Parseに失敗した場合の処理
}
```

これに対してOption型は、その必要がありません。

```csharp
str.ToIntOption().Match(
    result => /* 変換に成功した場合の式 */,
    () => /* 変換に失敗した場合の式 */);
```

Optionを使用すると、式として記述できる表現の幅が大きく広がるため、単純なラムダ式で記述できる処理の幅も大きく広がります。

Option型の値を生成するためには、Optionモジュールの関数・プロパティを使用します。
Option.Some/Option.None以外に、Option.Createという関数により、nullの場合Noneとして、それ以外の場合SomeとしてOptionオブジェクトを生成できます。

Option型はクエリ式で使うこともできます。

```csharp
from a in F1() // Option[int]を返す関数F1
from b in F2() // Option[int]を返す関数F2
from c in F3() // Option[string]を返す関数F3
select c + (a + b)
```

F1の結果を捨てる場合、&&演算子を使うことで余分な変数名の導入を避けることでできます。

```csharp
// F1の結果は捨て、F2の結果のみ使う
from a in F1() && F2()
from c in F3()
select c + a
```

ただし、これができるのは&&の両辺の型が同じである時のみです。
もし型が違う場合は、AndThenメソッドが使えます。

```csharp
// F1の結果は捨て、F3の結果のみ使う
from c in F1().AndThen(() => F3()) // もしくは単に F1().AndThen(F3)
from b in F2()
select c + b
```

これらのイディオムは重要です。

クエリ式は、「一つでも失敗したら失敗する」ことを表現しますが、||演算子を使うことで「一つでも成功したら成功する」ことも表現できます。

```csharp
return F1() || F2() || F3().Select(int.Parse);
```

この場合、すべての戻り値の型が同じでなければいけません。

### Createモジュール
Createモジュールは、LangExtやC#の標準ライブラリで扱うことのできる様々な型の値を生成するための関数を提供します。

たとえば、Create.Array(1, 2, 3)とすると、1, 2, 3という要素を持った配列を生成することができます。
この程度の例であれば、配列リテラルを使用したほうがいいですが、配列リテラルは関数として扱うことができませんので、高階関数の引数等に指定できません。
そういう場合にこのモジュールは役に立つでしょう(もちろん、値を生成するために便利な場合もあります)。

### TupleModuleモジュール
TupleModuleモジュールは、C#標準のタプルを使いやすくするための拡張メソッドを提供します。

C#標準のタプルは、7要素までしか自然に扱うことができませんが、TupleModuleモジュールを使うことで型の記述以外は16要素まで自然に扱うことができるようになります。
例えば、標準ライブラリでは16要素タプルの15要素目にアクセスするためには`tpl.Rest.Rest.Item1`と記述する必要がありますが、LangExtを使うと`tpl.\_15()`と書けます。
タプルの生成も、9要素以上はコンストラクタを使う必要があるため、非常に面倒です。

```csharp
var tpl = new Tuple<T1, T2, ..., T7, Tuple<T8, T9, ..., T14, Tuple<T15, T16>>>(
    t1, t2, ..., t7, new Tuple<T8, T9, ..., T14, Tuple<T15, T16>>(
        t8, t9, ..., t14, Tuple.Create(t15, t16)));
```

LangExtでは、これもとても簡単に記述できます。

```csharp
var tpl = Create.Tuple(t1, t2, ..., t16);
```

ほかにも、タプルの擬似的なパターンマッチや、指定要素に対するMapなどが可能です。

C#ではそもそもタプルを多用すべきではありません(無名型が使えるのであればそちらを使うといいでしょう)。
このモジュールは自動生成や、次に説明するFuncモジュールのために実装されています。
このモジュールで扱えるタプルの要素数が16までなのは、標準のFuncデリゲートが16引数までしか対応していないためです。


このモジュールには、関数のカリー化、アンカリー化も含まれます。
アンカリー化は、カリー化された関数を複数引数の関数に変換するUncurryと、タプルを1つ受け取る関数に変換するTupledの2つがあります。
