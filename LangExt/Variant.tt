<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Config.ttinclude" #>
using System;

namespace LangExt
{
<#
for (int i = 2; i <= Max; i++) {
    var types = Seq("T{0}", i);
#>
    /// <summary>
    /// 複数の型を持ちうる際に使用するデータ型です。
    /// </summary>
<# for (int j = 0; j < i; j++) { #>
    /// <typeparam name="T<#= j + 1 #>">型 <#= j + 1 #>。</typeparam>
<# } #>
    public sealed class Variant<<#= types #>> : IEquatable<Variant<<#= types #>>>
    {
<# for (int j = 0; j < i; j++) { #>
        readonly Option<T<#= j + 1 #>> t<#= j + 1 #>;
<# } #>

<# for (int j = 0; j < i; j++) { #>
        /// <summary>
        /// <#= j + 1 #> つ目の型の値を持つオブジェクトを構築します。
        /// </summary>
        /// <param name="value">値。</param>
        public Variant(T<#= j + 1 #> value)
        {
            t<#= j + 1 #> = new Option<T<#= j + 1 #>>(value);
        }

        /// <summary>
        /// <#= j + 1 #> つ目の型の値からその値を保持する Variant に変換します。
        /// </summary>
        /// <param name="value">値。</param>
        /// <returns>引数で指定された値を保持する Variant。</returns>
        public static implicit operator Variant<<#= types #>>(T<#= j + 1 #> value)
        {
            return new Variant<<#= types #>>(value);
        }

<# } #>
        /// <summary>
        /// 疑似的にパターンマッチを行います。
        /// </summary>
        /// <typeparam name="T">パターンマッチが返す値の型。</typeparam>
<# for (int j = 0; j < i; j++) { #>
        /// <param name="ifT<#= j + 1 #>">このオブジェクトが <#= j + 1 #> つ目の型の値を保持していた場合の処理。</param>
<# } #>
        /// <returns>処理が返した値。</returns>
        public T Match<T>(<#= Seq("Func<T{0}, T> ifT{0}", i) #>)
        {
            Func<Unit, T> thrower = _ => { throw new InvalidOperationException(); };
            return t1.Match<T>(ifT1, 
<# for (int j = 1; j < i; j++) { #>
<# if(j == (i - 1)) { #>
                                _<#= j + 1 #> => t<#= j + 1 #>.Match<T>(ifT<#= j + 1 #>, thrower)<# }else{ #>
                                _<#= j + 1 #> => t<#= j + 1 #>.Match<T>(ifT<#= j + 1 #>, <# } #>
                                <# } #><# for (int j = 2; j < i; j++) { #>)<# } #>
                                );
        }

        /// <summary>
        /// 現在のオブジェクトが、同じ型の別のオブジェクトと等しいかどうかを示します。
        /// </summary>
        /// <param name="other">このオブジェクトと比較する Variant。</param>
        /// <returns>現在のオブジェクトが other パラメータと等しい場合は true。それ以外の場合は false。</returns>
        public bool Equals(Variant<<#= types #>> other)
        {
            return other != null && <#= Seq("t{0} == other.t{0}", " && ", 1, i) #>;
        }

        /// <summary>
        /// 2 つの Variant の比較を行います。
        /// </summary>
        /// <param name="a">1 つ目の Variant。</param>
        /// <param name="b">2 つ目の Variant。</param>
        /// <returns>2 つの Variant が等しい場合は true、それ以外の場合は false。</returns>
        public static bool operator ==(Variant<<#= types #>> a, Variant<<#= types #>> b)
        {
            if (ReferenceEquals(a, null))
                return ReferenceEquals(b, null);
            return a.Equals(b);
        }

        /// <summary>
        /// 2 つの Variant の比較を行います。
        /// </summary>
        /// <param name="a">1 つ目の Variant。</param>
        /// <param name="b">2 つ目の Variant。</param>
        /// <returns>2 つの Variant が等しい場合は false、それ以外の場合は true。</returns>
        public static bool operator !=(Variant<<#= types #>> a, Variant<<#= types #>> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// 現在のオブジェクトが、別のオブジェクトと等しいかどうかを示します。
        /// </summary>
        /// <param name="obj">このオブジェクトと比較するオブジェクト。</param>
        /// <returns>現在のオブジェクトが obj パラメータと等しい場合は true。それ以外の場合は false。</returns>
        public override bool Equals(object obj)
        {
            var other = obj as Variant<<#= types #>>;
            if (other == null)
                return false;
            return Equals((Variant<<#= types #>>)other);
        }

        /// <summary>
        /// 現在のオブジェクトのハッシュコードを取得します。
        /// </summary>
        /// <returns>現在のオブジェクトのハッシュコード。</returns>
        public override int GetHashCode()
        {
            var result = 31;
<# for (int j = 0; j < i; j++) { #>
            result ^= t<#= j + 1 #>.GetHashCode();
<# } #>
            return result;
        }

        /// <summary>
        /// 現在のオブジェクトを文字列表現に変換します。
        /// </summary>
        /// <returns>現在のオブジェクトの文字列表現。</returns>
        public override string ToString()
        {
            return Match(
<# for (int j = 0; j < i; j++) { #>
                t<#= j + 1 #> => string.Format("Variant({0}:{1})", t<#= j + 1 #>, typeof(T<#= j + 1 #>).Name)<#= (j + 1) != i ? "," : ""  #>
<# } #>
            );
        }
    }
<# } #>
}