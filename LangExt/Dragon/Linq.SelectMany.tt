<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../Config.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;

namespace LangExt.Dragon
{
    partial class Linq
    {
<#
for (int i = 2; i <= Max; i++) {
	var types = Seq("T{0}", i);
	var args = Seq("t._{0}", i);
#>
        /// <summary>
        /// タプルのシーケンスの各要素を展開して selector に渡す flatMap です。
        /// </summary>
<# for (int j = 0; j < i; j++) { #>
        /// <typeparam name="T<#= j + 1 #>">シーケンスの保持する <#= j + 1 #> つ目の型。</typeparam>
<# } #>
        /// <typeparam name="TResult">selector によって返されるシーケンスの要素の型。</typeparam>
        /// <param name="self">変換関数を呼び出す対象となる値のシーケンス。</param>
        /// <param name="selector">各要素に適用する変換関数。</param>
        /// <returns>self の各要素に対して一対多の変換関数を呼び出した結果として得られる要素を含むシーケンス。</returns>
        public static IEnumerable<TResult> SelectMany<<#= types #>, TResult>(this IEnumerable<_<<#= types #>>> self, Func<<#= types #>, IEnumerable<TResult>> selector)
        {
            return self.SelectMany(t => selector(<#= args #>));
        }

        /// <summary>
        /// タプルのシーケンスの各要素を展開して selector に渡す flatMap です。
        /// </summary>
<# for (int j = 0; j < i; j++) { #>
        /// <typeparam name="T<#= j + 1 #>">シーケンスの保持する <#= j + 1 #> つ目の型。</typeparam>
<# } #>
        /// <typeparam name="TResult">selector によって返されるシーケンスの要素の型。</typeparam>
        /// <param name="self">変換関数を呼び出す対象となる値のシーケンス。</param>
        /// <param name="selector">各要素に適用する変換関数。最後のパラメータにはインデックスが渡されます。</param>
        /// <returns>self の各要素に対して一対多の変換関数を呼び出した結果として得られる要素を含むシーケンス。</returns>
        public static IEnumerable<TResult> SelectMany<<#= types #>, TResult>(this IEnumerable<_<<#= types #>>> self, Func<<#= types #>, int, IEnumerable<TResult>> selector)
        {
            return self.SelectMany((t, i) => selector(<#= args #>, i));
        }

        /// <summary>
        /// タプルのシーケンスの各要素を展開して selector に渡す flatMap です。
        /// </summary>
<# for (int j = 0; j < i; j++) { #>
        /// <typeparam name="T<#= j + 1 #>">シーケンスの保持する <#= j + 1 #> つ目の型。</typeparam>
<# } #>
        /// <typeparam name="TCollection">collectionSelector によって収集される中間要素の型。</typeparam>
        /// <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        /// <param name="self">変換関数を呼び出す対象となる値のシーケンス。</param>
        /// <param name="collectionSelector">各要素に適用する変換関数。</param>
        /// <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。</param>
        /// <returns>self の各要素に対して一対多の変換関数 collectionSelector を呼び出し、こうしたシーケンスの各要素とそれに対応するソース要素を結果の要素に割り当てた結果として得られる要素を含むシーケンス。</returns>
        public static IEnumerable<TResult> SelectMany<<#= types #>, TCollection, TResult>(this IEnumerable<_<<#= types #>>> self, Func<<#= types #>, IEnumerable<TCollection>> collectionSelector, Func<<#= types #>, TCollection, TResult> resultSelector)
        {
            return self.SelectMany(t => collectionSelector(<#= args #>), (t, c) => resultSelector(<#= args #>, c));
        }

<# /* 型推論がうまくきかなくなってしまうのでちょっと断念 #>
        /// <summary>
        /// タプルのシーケンスの各要素を展開して selector に渡す flatMap です。
        /// </summary>
<# for (int j = 0; j < i; j++) { #>
        /// <typeparam name="T<#= j + 1 #>">シーケンスの保持する <#= j + 1 #> つ目の型。</typeparam>
<# } #>
        /// <typeparam name="TCollection">collectionSelector によって収集される中間要素の型。</typeparam>
        /// <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        /// <param name="self">変換関数を呼び出す対象となる値のシーケンス。</param>
        /// <param name="collectionSelector">各要素に適用する変換関数。最後のパラメータにはインデックスが渡されます。</param>
        /// <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。最後のパラメータにはインデックスが渡されます。</param>
        /// <returns>self の各要素に対して一対多の変換関数 collectionSelector を呼び出し、こうしたシーケンスの各要素とそれに対応するソース要素を結果の要素に割り当てた結果として得られる要素を含むシーケンス。</returns>
        public static IEnumerable<TResult> SelectMany<<#= types #>, TCollection, TResult>(this IEnumerable<_<<#= types #>>> self, Func<<#= types #>, int, IEnumerable<TCollection>> collectionSelector, Func<<#= types #>, int, TCollection, TResult> resultSelector)
        {
            return self.SelectMany((t, i) => collectionSelector(<#= args #>, i), (t, i, c) => resultSelector(<#= args #>, i, c));
        }
<# */ #>
<# } #>
    }
}