<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Config.ttinclude" #>
using System;

namespace LangExt
{
    partial class ObjectUtil
    {
<#
for (int i = 1; i <= Max; i++) {
	var types = Seq("T{0}", i);
	var funcs = Seq("Func<T{0}, TResult> ifT{0}", i);
#>
        /// <summary>
        /// 型パラメータの先頭から順にキャスト出来るかを is 演算子で調べ、is 演算子が true を返した型に対応する処理を実行して返します。
        /// どの型にも変換できなかった場合、例外を送出します。
        /// </summary>
<# for (int j = 0; j < i; j++) { #>
        /// <typeparam name="T<#= j + 1 #>">変換を試みる <#= j + 1 #> つ目の型。</typeparam>
<# } #>
        /// <typeparam name="TResult">処理の戻り値の型。</typeparam>
        /// <param name="self">変換対象。</param>
<# for (int j = 0; j < i; j++) { #>
        /// <param name="ifT<#= j + 1 #>">T<#= j + 1 #> つ目の型に変換できた場合に実行される処理。</param>
<# } #>
        /// <returns>処理の結果。</returns>
        public static TResult TypeMatch<<#= types #>, TResult>(this object self, <#= funcs #>)
        {
<# for (int j = 0; j < i; j++) { #>
            if (self is T<#= j + 1 #>)
                return ifT<#= j + 1 #>((T<#= j + 1 #>)self);
<# } #>
            throw new Exception();
        }

        /// <summary>
        /// 型パラメータの先頭から順にキャスト出来るかを is 演算子で調べ、is 演算子が true を返した型に対応する処理を実行して返します。
        /// どの型にも変換できなかった場合、otherwise で指定した処理を実行して返します。
        /// </summary>
<# for (int j = 0; j < i; j++) { #>
        /// <typeparam name="T<#= j + 1 #>">変換を試みる <#= j + 1 #> つ目の型。</typeparam>
<# } #>
        /// <typeparam name="TResult">処理の戻り値の型。</typeparam>
        /// <param name="self">変換対象。</param>
<# for (int j = 0; j < i; j++) { #>
        /// <param name="ifT<#= j + 1 #>">T<#= j + 1 #> つ目の型に変換できた場合に実行される処理。</param>
<# } #>
        /// <param name="otherwise">どの型にも変換できなかった場合に実行される処理。</param>
        /// <returns>処理の結果。</returns>
        public static TResult TypeMatch<<#= types #>, TResult>(this object self, <#= funcs #>, Func<TResult> otherwise)
        {
<# for (int j = 0; j < i; j++) { #>
            if (self is T<#= j + 1 #>)
                return ifT<#= j + 1 #>((T<#= j + 1 #>)self);
<# } #>
            return otherwise();
        }

<# } #>
    }
}
