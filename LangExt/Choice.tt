<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\T4\T4Util.ttinclude" #>
using System;
using System.ComponentModel;

namespace LangExt
{
<#
for (int i = 2; i <= Max; i++) {
    var types = TypeParams("T", i);
#>
    public sealed class Choice<<#= types #>> : IEquatable<Choice<<#= types #>>>
    {
<# for (int j = 0; j < i; j++) { #>
        internal readonly Option<T<#= j + 1 #>> Case<#= j + 1 #>;
<# } #>

        public int TagIndex { get { return this.Match(<#= Repeat(", ", "_ => {0}", i) #>); } }

<# for (int j = 0; j < i; j++) { #>
        public Choice(T<#= j + 1 #> value) { Case<#= j + 1 #> = new Option<T<#= j + 1 #>>(value); }

        public static implicit operator Choice<<#= types #>>(T<#= j + 1 #> value) { return new Choice<<#= types #>>(value); }

<# } #>

        public T Match<T>(<#= Repeat(", ", "Func<T{0}, T> Case{0}", i) #>)
        {
            Func<T> thrower = () => { throw new InvalidOperationException(); };
            return <#= Fold("() => this.Case" + i + ".Match<T>(Case" + i + ", thrower)", "() => this.Case{1}.Match<T>(Case{1}, {0})", i - 1).Substring("() => ".Length) #>;
        }

        public bool Equals(Choice<<#= types #>> other)
        {
            return other.IsNotNull() && <#= Repeat(" && ", "Case{0} == other.Case{0}", i) #>;
        }

        public static bool operator ==(Choice<<#= types #>> a, Choice<<#= types #>> b)
        {
            if (a.IsNull())
                return b.IsNull();
            return a.Equals(b);
        }

        public static bool operator !=(Choice<<#= types #>> a, Choice<<#= types #>> b)
        {
            return !(a == b);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj)
        {
            var other = obj as Choice<<#= types #>>;
            if (other.IsNull())
                return false;
            return Equals(other);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode()
        {
            var result = 31;
<# for (int j = 0; j < i; j++) { #>
            result ^= Case<#= j + 1 #>.GetHashCode();
<# } #>
            return result;
        }

        public override string ToString()
        {
            return Match(
<# for (int j = 0; j < i; j++) { #>
                t<#= j + 1 #> => string.Format("Choice({0}:{1})", t<#= j + 1 #>, typeof(T<#= j + 1 #>).Name)<#= (j + 1) != i ? "," : ""  #>
<# } #>
            );
        }
    }

<# } #>
}