<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
    <a href="index.html">index</a>
</div>
<hr>
<h1 id="langext.compatibility.fsharp">LangExt.Compatibility.FSharp</h1>
<p>これは、LangExt.Compatibility.FSharpの概要を説明するドキュメントです。</p>
<h2 id="langext.compatibility.fsharpとは">LangExt.Compatibility.FSharpとは</h2>
<p>LangExt.Compatibility.FSharpは、LangExtを用いたC#のコードとF#のコードを繋ぐためのライブラリです。</p>
<p>LangExt.Compatibility.FSharpの機能のみをF#から利用する場合、 必要にならない限りLangExtをopenせず、LangExt.Compatibility.FSharpのみをopenしてください。</p>
<p>C#からこのライブラリを利用することは現状であまり考えていませんが、 今後は何かしらの対応を入れる可能性はあります。</p>
<h2 id="langext.compatibility.fsharpが提供する主な機能">LangExt.Compatibility.FSharpが提供する主な機能</h2>
<p>LangExt.Compatibility.FSharpが提供する主な機能について、その役割や意味を簡単に説明します。 実際の使い方に関しては、ドキュメンテーションコメント等を参考にしてください。</p>
<h3 id="langextの型に対する別名">LangExtの型に対する別名</h3>
<p>LangExt.Compatibility.FSharpでは、LangExtが提供する型のうちOptionとResultにそれぞれ、 <code>CsOption</code>、<code>CsResult</code>という別名を提供しています。</p>
<p>OptionはF#にも存在するための別名ですが、Resultは標準の範囲ではF#にはありません。 しかし、他のF#ライブラリで提供されることが考えられるため、別名を用意しています。</p>
<h3 id="langextのoptionを生成する">LangExtのOptionを生成する</h3>
<p>CsOptionモジュールにLangExtのOptionを生成するための関数があります。</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> f x =
  <span class="kw">if</span> x = 0 <span class="kw">then</span> CsOption<span class="kw">.</span>none <span class="kw">else</span> CsOption<span class="kw">.</span>some x</code></pre>
<h3 id="langextのoptionをmatch式に使う">LangExtのOptionをmatch式に使う</h3>
<p>LangExtのOptionに対してアクティブパターンを提供しており、match式で使用可能です。</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">match</span> opt <span class="kw">with</span>
| <span class="dt">CsSome</span> v -&gt; sprintf <span class="st">&quot;%A&quot;</span> v
| <span class="dt">CsNone</span> -&gt; <span class="st">&quot;none&quot;</span></code></pre>
<h3 id="langextのresultをmatch式に使う">LangExtのResultをmatch式に使う</h3>
<p>LangExtのResultに対してアクティブパターンを提供しており、match式で使用可能です。</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">match</span> res wit
| <span class="dt">CsSuccess</span> x -&gt; sprintf <span class="st">&quot;%A&quot;</span> x
| <span class="dt">CsFailure</span> x -&gt; sprintf <span class="st">&quot;%A&quot;</span> x</code></pre>
<h3 id="langextのoptionとfのoptionの相互変換">LangExtのOptionとF#のOptionの相互変換</h3>
<p>CsOptionモジュールとFsOptionモジュールに、LangExtのOptionとF#のOptionの相互変換を行うための関数があります。</p>
<p>LangExtのOptionからF#のOptionに変換する場合、<code>CsOption.toFsOption</code>か、<code>FsOption.ofCsOption</code>を使います。 この2つはまったく同じ機能を持ちますが、語順を意識してより自然に見えるように使い分けましょう。</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* 自然な語順 *)</span>
<span class="kw">let</span> f (x: <span class="dt">CsOption&lt;&#39;a&gt;</span>) =
  x |&gt; CsOption<span class="kw">.</span>toFsOption |&gt; Option<span class="kw">.</span>get

<span class="co">(* 不自然な語順 *)</span>
<span class="kw">let</span> g (x: <span class="dt">CsOption&lt;&#39;a&gt;</span>) =
  x |&gt; FsOption<span class="kw">.</span>ofCsOption |&gt; Option<span class="kw">.</span>get</code></pre>
<p>このように、パイプライン演算子を使う場合は<code>CsOption.toFsOption</code>を使うほうが自然です。 それに対して、</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* 自然な語順 *)</span>
<span class="kw">let</span> f (x: <span class="dt">CsOption&lt;&#39;a&gt;</span>) =
  <span class="kw">let</span> opt = FsOption<span class="kw">.</span>ofCsOption x
  Option<span class="kw">.</span>get opt

<span class="co">(* 不自然な語順 *)</span>
<span class="kw">let</span> g (x: <span class="dt">CsOption&lt;&#39;a&gt;</span>) =
  <span class="kw">let</span> opt = CsOption<span class="kw">.</span>toFsOption x
  Option<span class="kw">.</span>get opt</code></pre>
<p>のように、関数適用の形で使う場合は<code>FsOption.ofCsOption</code>を使うほうがより自然になります。</p>
<p>これらの逆の変換を行う<code>FsOption.toCsOption</code>と、<code>CsOption.ofFsOption</code>も定義されています。</p>
<hr>
<div id="footer">
    <a href="index.html">index</a>
</div>
</body>
</html>
